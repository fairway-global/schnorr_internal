pragma language_version >= 0.12.0;
import CompactStandardLibrary;


circuit point_to_bytes(p: CurvePoint): Bytes<32> {
    return persistentHash<CurvePoint>(p);
}

export struct Signature {
    pk: CurvePoint;
    R: CurvePoint;
    s: Field;
}

struct Bytes96 {
    b0: Bytes<32>;
    b1: Bytes<32>;
    b2: Bytes<32>;
}

struct Bytes64 {
    b0: Bytes<32>;
    b1: Bytes<32>;
}

struct Bytes47 {
    b0: Bytes<15>;
    b1: Bytes<32>;
}

export struct CredentialSubject {
    id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)
    first_name: Bytes<32>; // The first name of the subject
    last_name: Bytes<32>; // The last name of the subject
    national_identifier: Bytes<32>; // The national identifier of the subject
    birth_timestamp: Uint<64>; // The birth timestamp of the subject
}

export struct SignedCredentialSubject {
    subject: CredentialSubject;
    signature: Signature;
}

constructor() {
}

// Hash the credential subject to a fixed-size representation
export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {
    return persistentHash<CredentialSubject>(credentialSubject);
}

// Derive public key from private key
export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {
    const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
    const sk_field: Field = sk_bytes15 as Field;
    assert(sk_field != 0, "Private key cannot be zero");
    const pk: CurvePoint = ecMulGenerator(sk_field);
    return pk;
}

export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {
    // Extract consistent 15-byte private key
    const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
    const sk_field: Field = sk_bytes15 as Field;

    const pk = derive_pk(sk_bytes);

    // Use consistent 15-byte input for nonce generation
    const nonce_input: Bytes47 = Bytes47 { b0: sk_bytes15, b1: msg };
    const k_hash: Bytes<32> = persistentHash<Bytes47>(nonce_input);
    const k_bytes15: Bytes<15> = slice<15>(k_hash, 0);
    const k_field: Field = k_bytes15 as Field;
    assert(k_field != 0, "Nonce cannot be zero");

    // Compute R = k * B
    const R: CurvePoint = ecMulGenerator(k_field);

    // Compute challenge: c = H(R || pk || msg)
    const R_bytes: Bytes<32> = point_to_bytes(R);
    const pk_bytes: Bytes<32> = point_to_bytes(pk);
    const c_bytes: Bytes96 = Bytes96 {
        b0: R_bytes,
        b1: pk_bytes,
        b2: msg
    };
    
    const c_field_raw: Field = transientHash<Bytes96>(c_bytes);
    const c_hash: Bytes<32> = persistentHash<Bytes96>(c_bytes);

    const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
    const c_field: Field = c_bytes15 as Field;
    assert(c_field != 0, "Challenge cannot be zero");
 
    // Compute signature: s = k + c * sk
    const s: Field = k_field + (c_field * sk_field);

    return Signature { pk: pk, R: R, s: s };
}

export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {
        const {pk, R, s} = signature;
        // Compute challenge: c = H(R || pk || msg)
        const R_bytes: Bytes<32> = point_to_bytes(R);
        const pk_bytes: Bytes<32> = point_to_bytes(pk);
        const c_bytes: Bytes96 = Bytes96 {
            b0: R_bytes,
            b1: pk_bytes,
            b2: msg
        };
        
        // Use the same approach as in sign() function
        const c_field_raw: Field = transientHash<Bytes96>(c_bytes);
        const c_hash: Bytes<32> = persistentHash<Bytes96>(c_bytes);
        
        const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
        const c_field: Field = c_bytes15 as Field;
        assert(c_field != 0, "Challenge cannot be zero");

        // Left-hand side: s * B
        const lhs: CurvePoint = ecMulGenerator(s);

        // Right-hand side: R + c * pk
        const c_pk: CurvePoint = ecMul(pk, c_field);
        const rhs: CurvePoint = ecAdd(R, c_pk);

        // Enforce verification equation
        assert(lhs == rhs, "Signature verification failed");
}

export pure circuit hash_field_to_bytes32(input: Field): Bytes<32> {
    const value_hash: Bytes<32> = persistentHash<Field>(input);
    return value_hash;
}
