pragma language_version >= 0.12.0;
import CompactStandardLibrary;


export struct Signature {
    pk: CurvePoint;
    R: CurvePoint;
    s: Field;
}

struct Bytes96 {
    b0: Bytes<32>;
    b1: Bytes<32>;
    b2: Bytes<32>;
}

struct Bytes64 {
    b0: Bytes<32>;
    b1: Bytes<32>;
}

struct Bytes79 {
    b0: Bytes<15>;
    b1: Bytes<32>;
    b3: Bytes<32>;
}

export struct CredentialSubject {
    id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)
    first_name: Bytes<32>; // The first name of the subject
    last_name: Bytes<32>; // The last name of the subject
    national_identifier: Bytes<32>; // The national identifier of the subject
    birth_timestamp: Uint<64>; // The birth timestamp of the subject
}

export struct SignedCredentialSubject {
    subject: CredentialSubject;
    signature: Signature;
}

export ledger fairway_pk: CurvePoint;
witness localSigningKey(): Bytes<32>;
witness signingNonce(): Bytes<32>;

constructor() {
    assert(disclose(localSigningKey()) != default<Bytes<32>>, "Private key cannot be zero");
    fairway_pk = derive_pk(disclose(localSigningKey()));
}

// Hash the credential subject to a fixed-size representation
export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {
    return persistentHash<CredentialSubject>(credentialSubject);
}

circuit point_to_bytes(p: CurvePoint): Bytes<32> {
    return persistentHash<CurvePoint>(p);
}

// Derive public key from private key
export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {
    assert(sk_bytes != default<Bytes<32>>, "Private key cannot be zero");
    const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
    const sk_field: Field = sk_bytes15 as Field;

    const pk: CurvePoint = ecMulGenerator(sk_field);
    return pk;
}

export circuit sign(msg: Bytes<32>): Signature {
    // Extract consistent 15-byte private key
    const sk_bytes: Bytes<32> = disclose(localSigningKey());
    assert(sk_bytes != default<Bytes<32>>, "Private key cannot be zero");
    const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
    const sk_field: Field = sk_bytes15 as Field;

    const pk = derive_pk(sk_bytes);

    // Use consistent 15-byte input for nonce generation
    const nonce_input: Bytes79 = Bytes79 { b0: sk_bytes15, b1: msg, b3: disclose(signingNonce()) };
    const k_hash: Bytes<32> = persistentHash<Bytes79>(nonce_input);
    const k_bytes15: Bytes<15> = slice<15>(k_hash, 0);
    const k_field: Field = k_bytes15 as Field;
    assert(k_field != 0, "Nonce cannot be zero");

    // Compute R = k * B
    const R: CurvePoint = ecMulGenerator(k_field);

    // Compute challenge: c = H(R || pk || msg)
    const R_bytes: Bytes<32> = point_to_bytes(R);
    const pk_bytes: Bytes<32> = point_to_bytes(pk);
    const c_bytes: Bytes96 = Bytes96 {
        b0: R_bytes,
        b1: pk_bytes,
        b2: msg
    };

    const c_hash: Bytes<32> = persistentHash<Bytes96>(c_bytes);

    const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
    const c_field: Field = c_bytes15 as Field;
    assert(c_field != 0, "Challenge cannot be zero");
 
    // Compute signature: s = k + c * sk
    const s: Field = k_field + (c_field * sk_field);

    return Signature { pk: pk, R: R, s: s };
}

export circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {
        const {pk, R, s} = signature;
        assert(pk == fairway_pk, "Public key mismatch");
        // Compute challenge: c = H(R || pk || msg)
        const R_bytes: Bytes<32> = point_to_bytes(R);
        const pk_bytes: Bytes<32> = point_to_bytes(pk);
        const c_bytes: Bytes96 = Bytes96 {
            b0: R_bytes,
            b1: pk_bytes,
            b2: msg
        };
        
        // Use the same approach as in sign() function
        const c_hash: Bytes<32> = persistentHash<Bytes96>(c_bytes);
        
        const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
        const c_field: Field = c_bytes15 as Field;
        assert(c_field != 0, "Challenge cannot be zero");

        // Left-hand side: s * B
        const lhs: CurvePoint = ecMulGenerator(s);

        // Right-hand side: R + c * pk
        const c_pk: CurvePoint = ecMul(pk, c_field);
        const rhs: CurvePoint = ecAdd(R, c_pk);

        // Enforce verification equation
        assert(lhs == rhs, "Signature verification failed");
}
